name: Weekly Digest

on:
  workflow_dispatch: {}     # ← keeps the "Run workflow" button
  schedule:
    - cron: "5 0 * * 1"     # Mondays 00:05 UTC

jobs:
  weekly:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: write
      id-token: write
    env:
      LOGS_DIR: logs
      OUTFILE: outputs/weekly.md
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps (if any)
        run: |
          python -m pip install --upgrade pip

      - name: Compute previous Monday..Sunday (UTC)
        id: daterange
        shell: bash
        run: |
          # Previous full Monday..Sunday window in UTC.
          DOW=$(date -u +%u)            # 1..7 (Mon..Sun)
          THIS_MON=$(date -u -d "last monday" +%Y-%m-%d)
          if [ "$DOW" = "1" ]; then
            # If today is Monday, "last monday" is today → push back 7 days
            THIS_MON=$(date -u -d "$THIS_MON -7 days" +%Y-%m-%d)
          fi
          THIS_SUN=$(date -u -d "$THIS_MON +6 days" +%Y-%m-%d)
          echo "start=$THIS_MON" >> $GITHUB_OUTPUT
          echo "end=$THIS_SUN"   >> $GITHUB_OUTPUT
          echo "Computed weekly window (UTC): $THIS_MON .. $THIS_SUN"

      - name: Diagnostics — repo & logs presence
        shell: bash
        run: |
          echo "***"
          echo "GITHUB_WORKSPACE=$(pwd)"
          echo
          echo "Tracked files under logs/ (git):"
          git ls-files "logs/*" || true
          echo
          echo "INPUT_DIR content:"
          ls -la "$LOGS_DIR" || true

      - name: Diagnostics — match notes by filename date (robust)
        shell: bash
        env:
          START: ${{ steps.daterange.outputs.start }}
          END:   ${{ steps.daterange.outputs.end }}
          INPUT_DIR: ${{ env.LOGS_DIR }}
        run: |
          python - <<'PY'
import os, re, sys, glob, datetime as dt
inp = os.environ.get("INPUT_DIR","logs")
start = dt.date.fromisoformat(os.environ["START"])
end   = dt.date.fromisoformat(os.environ["END"])
rx = re.compile(r"notes-(\d{4}-\d{2}-\d{2})\.md$", re.I)

candidates = sorted(glob.glob(os.path.join(inp, "notes-*.md")))
matches = []
for p in candidates:
    m = rx.search(os.path.basename(p))
    if not m:
        continue
    d = dt.date.fromisoformat(m.group(1))
    if start <= d <= end:
        matches.append((d.isoformat(), p))

print(f"Matching notes-YYYY-MM-DD.* within {start}..{end} (by filename date):")
if matches:
    for d,p in sorted(matches):
        print(f"  ✓ {d}  -> {p}")
    print(f"TOTAL MATCHES: {len(matches)}")
else:
    print("  (none)")
PY

      - name: Aggregate logs → weekly.md (group Actions)
        shell: bash
        run: |
          mkdir -p outputs
          python scripts/digest_aggregate.py \
            --logs-dir "$LOGS_DIR" \
            --start "${{ steps.daterange.outputs.start }}" \
            --end   "${{ steps.daterange.outputs.end }}" \
            --output "$OUTFILE" \
            --title  "Team Digest (${{ steps.daterange.outputs.start }} - ${{ steps.daterange.outputs.end }})" \
            --group-actions \
            --expect-missing
          echo "---- Preview (first 60 lines) ----"
          head -n 60 "$OUTFILE" || true

      - name: Sanity fail if fully empty
        shell: bash
        run: |
          if grep -q "_No summary._" "$OUTFILE" && \
             grep -q "_No decisions._" "$OUTFILE" && \
             grep -q "_No actions._" "$OUTFILE" && \
             grep -q "_No risks._" "$OUTFILE" && \
             grep -q "_No dependencies._" "$OUTFILE" && \
             grep -q "_No notes._" "$OUTFILE"; then
            echo "::error::Digest contains no content; likely date/window mismatch or wrong path."
            exit 2
          fi

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: weekly-digest
          path: ${{ env.OUTFILE }}

      - name: Post to Slack (optional)
        if: env.SLACK_WEBHOOK_URL != ''
        run: |
          python scripts/post_to_slack.py "$OUTFILE"
