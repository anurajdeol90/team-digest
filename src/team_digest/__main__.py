#!/usr/bin/env python
from __future__ import annotations

import argparse
import datetime as dt
from pathlib import Path
from typing import Optional

from .team_digest_runtime import aggregate_range

try:
    from . import __version__ as VERSION
except Exception:
    VERSION = "unknown"


def _write_output(text: str, output: Optional[str]) -> None:
    if output:
        p = Path(output)
        p.parent.mkdir(parents=True, exist_ok=True)
        p.write_text(text, encoding="utf-8")
    else:
        print(text)


def _parse_date(s: str) -> dt.date:
    return dt.date.fromisoformat(s)


def _infer_range_from_logs(logs_dir: Path) -> tuple[dt.date, dt.date]:
    """If dates aren’t provided, infer [min,max] from notes-YYYY-MM-DD.md in logs_dir."""
    dates: list[dt.date] = []
    for p in logs_dir.glob("notes-*.md"):
        try:
            d = dt.date.fromisoformat(p.stem.split("notes-")[1])
            dates.append(d)
        except Exception:
            pass
    if dates:
        return (min(dates), max(dates))
    today = dt.date.today()
    return (today, today)


def main() -> int:
    ap = argparse.ArgumentParser(prog="team-digest")
    sub = ap.add_subparsers(dest="cmd", required=True)

    common = {
        "logs_dir": {"flags": ["--logs-dir"], "kwargs": {"required": True}},
        "output": {"flags": ["--output"], "kwargs": {}},
        "group_actions": {
            "flags": ["--group-actions"],
            "kwargs": {"action": "store_true"},
        },
        "flat_by_name": {
            "flags": ["--flat-by-name"],
            "kwargs": {"action": "store_true"},
        },
        "emit_kpis": {"flags": ["--emit-kpis"], "kwargs": {"action": "store_true"}},
        "owner_breakdown": {
            "flags": ["--owner-breakdown"],
            "kwargs": {"action": "store_true"},
        },
        "owner_top": {"flags": ["--owner-top"], "kwargs": {"type": int, "default": 8}},
    }

    def add_common(p: argparse.ArgumentParser) -> None:
        p.add_argument(*common["logs_dir"]["flags"], **common["logs_dir"]["kwargs"])
        p.add_argument(*common["output"]["flags"], **common["output"]["kwargs"])
        p.add_argument(
            *common["group_actions"]["flags"], **common["group_actions"]["kwargs"]
        )
        p.add_argument(
            *common["flat_by_name"]["flags"], **common["flat_by_name"]["kwargs"]
        )
        p.add_argument(*common["emit_kpis"]["flags"], **common["emit_kpis"]["kwargs"])
        p.add_argument(
            *common["owner_breakdown"]["flags"], **common["owner_breakdown"]["kwargs"]
        )
        p.add_argument(*common["owner_top"]["flags"], **common["owner_top"]["kwargs"])

    p_daily = sub.add_parser("daily", help="Generate a digest for a single day")
    add_common(p_daily)
    p_daily.add_argument("--date", type=_parse_date, required=True)

    p_weekly = sub.add_parser("weekly", help="Generate a digest for a date range")
    add_common(p_weekly)
    p_weekly.add_argument("--start", type=_parse_date)
    p_weekly.add_argument("--end", type=_parse_date)

    p_monthly = sub.add_parser(
        "monthly", help="Generate a digest for a month or given range"
    )
    add_common(p_monthly)
    p_monthly.add_argument("--start", type=_parse_date)
    p_monthly.add_argument("--end", type=_parse_date)

    args = ap.parse_args()
    logs_dir = Path(args.logs_dir)

    if args.cmd == "daily":
        start = end = args.date
    else:
        start = getattr(args, "start", None)
        end = getattr(args, "end", None)
        if start is None or end is None:
            # Prefer deterministic behavior in CI: infer from available logs
            istart, iend = _infer_range_from_logs(logs_dir)
            start = start or istart
            end = end or iend

    text = aggregate_range(
        logs_dir=logs_dir,
        start=start,
        end=end,
        title=None,
        group_actions=args.group_actions,
        flat_by_name=args.flat_by_name,
        emit_kpis=args.emit_kpis,
        owner_breakdown=args.owner_breakdown,
        owner_top=args.owner_top,
    )

    # Append a small footer like your packaged output shows
    footer = (
        "\n---\n"
        f"_Digest generated by team-digest (v{VERSION}) — https://pypi.org/project/team-digest/_\n"
    )
    if not text.endswith("\n"):
        text += "\n"
    text += footer

    _write_output(text, getattr(args, "output", None))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
